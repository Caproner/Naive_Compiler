# Naive_Compiler

为了最终的编译原理大作业写的一个，  
非常奶衣服的一个，功能十分受限的编译器。  
其作用仅限于可以进行变量定义，赋值，计算，和输出。  
也懒得再加什么新功能了orz  

## 指令集（暂定）

+ `var x;`：定义变量`x`（浮点型），初值默认为0。
+ `var x = [expression];`：定义变量`x`（浮点型），并将`[expression]`的值赋给`x`。
+ `x = [expression];`：将表达式`[expression]`的值赋值给`x`，表达式仅支持带小括号的四则运算。
+ `print [expression];`：输出表达式`[expression]`的值。

## 使用方法

### 编译编译器

好吧读起来有点绕hhh  

+ 进入根目录
+ 使用命令`make clean`清空上一次编译的产物
+ 再使用命令`make`进行编译

### 运行编译器

Naive_C提供了两种不同的编译模式

#### 即时编译模式（交互模式）

+ 进入根目录，使用命令`./Naive`运行
+ 每次输入一行代码，以分号为结尾，也可以一行输入多个以分号结尾的语句
    - 例如`var x=2;`或者`x=x+2;y=y+3;`
+ 回车之后编译器便会编译代码，若为print语句则会输出对应结果
+ 若输入语句有错误的话，编译器会给出报错（只能报`词法分析出错`，`语法分析出错`，`语义分析出错`这三种）
+ 若需要查看编译过程的中间生成信息，则需要消除`main.cpp`和`Grammar/Grammar.cpp`中对`#define TEST`的注释，然后再`make`一次
    + 事先说明，中间生成信息十分混乱

交互模式的运行示例如下所示：  
```
capxchen@ubuntu:~/Ext/Git/Naive_Compiler$ ./Naive
[Naive by Caproner]
Welcome to use Naive_C!
 > var x=2;
 > print x+4;
6.000000
 > var y = x + 2;
 > print y;
4.000000
```

#### 文件编译模式

+ 在该目录下打开命令提示符，输入`./Naive 文件路径`即可编译运行该文件
    - 文件的路径可以是相对路径（例如要编译该项目自带的`Test.nac`，可以用`./Naive Test.nac`编译），也可以是绝对路径（例如`Naive /home/capxchen/Test/Test.nac`）
+ 暂定程序后缀名为`.nac`，虽然这无关紧要


## 进度

- [x] **Naive_Compiler开发**
    - [x] 词法分析
	    - [x] 设计指令集
		- [x] 列出内码表
		- [x] 完成对应的DFA
		- [x] 完成文法→单词列表的过程
	- [x] 语法分析
	    - [x] 设计文法
		- [x] 列出LR(1)分析表
		- [x] 完成单词列表→语法树的过程
	- [x] 语义分析及结果生成
	    - [x] 完成语法树→结果的过程

- [x] **LR(1)_Creater开发**
    - [x] 完成FOLLOW集和FIRST集的生成
	- [x] 完成DFA的生成
	- [x] 完成ACTION和GOTO的生成
	- [x] 对照已有样例测试通过
	- [x] 使用该产生器产生所需文法的分析表

## 开发日志

**2018/07/06**：删除了无用的文件，取消了对Dev_C++的依赖，并编写了`Makefile`以便于自行编译

**2018/05/28**：新增文件编译模式，并为了方便把原项目名`Naive_Compiler`改为`Naive`。

**2018/05/27**：晋太元中，武陵人摸鱼为业。

**2018/05/26**：晋太元中，武陵人摸鱼为业。

**2018/05/25**：Naive_Compiler整体完成，通过初步测试。不过可能会有部分未发现的bug。

**2018/05/24**：完成LR(1)分析器产生器，导出需要使用的文法的分析表。

**2018/05/23**：已完成词法分析部分，并完成LR(1)分析器产生器中FIRST&FOLLOW集的生成。

**2018/05/22**：吹下牛逼，开始看书。

